Date: 2013-12-31
Tags: Auth, Cryptography, Security, Tokens  

# A rough guide to security tokens

When you build an authentication service, you need to return some sort of token that allows resource servers to determine who the user is, what their privileges are, and often other information on which authorisation decisions might be made such as their detected country code or the identifier of the device they're using.

Most people don't give much thought to what this token should look like, and simply use whatever happens to be provided by whatever framework they're using. This is fine for small, self-contained systems, but if you want to start building a distributed system or interoperating with third parties then the token becomes part of your public interface, and so you're going to have to give it more thought.

Where do you start though? Security tokens seem _scary_, right? But there's not as much to them as you'd think, and there are some emerging standards which should make everybody's life a lot easier if they gain traction. Here's a rough guide to security tokens, written by somebody who is by no means an expert (i.e. use this information at your own risk).

## Claims

Before we dive into tokens, let's get a bit of terminology out of the way. I covered the difference between authentication and authorisation in my [REST API fundamentals](/blog/restful-api-design-the-fundamentals) post, but there's no harm in reiterating:

- Authentication: Exchange of credentials for a set of claims related to your identity (typically stored in a token).
- Authorisation: Evaluation of claims to determine whether you have permission to perform an action.

A claim is a piece of information about a user, which may be related to them (e.g. their user ID, their email address), to their current context (e.g. their device ID, their IP address), or even what they've done in the past (e.g. whether they've accepted the terms and conditions for your service). Usually one of these claims is a special claim that represents _who_ the user is; this is known as the 'subject' or 'identity' claim, and is often treated specially by services.

## Opaque Tokens

Arguably the simplest type of token is the opaque token. This is just a random string which the auth server generates and stores alongside the details of the user the token represents. When an interested party wants to know more about the user the token represents, they have to query the auth server.

The way this token provides security is by having sufficient entropy in the token that guessing an actual value would be statistically impossible, so when a value that exists in the auth server data store is presented back to it, it's reasonable to assume it was issued by the auth server.

Unfortunately, on hearing this the first thing that springs to most people's mind is a GUID because they know that collisions between GUIDs are statistically very unlikely. However, while the GUID specification is intended to make accidental collision very unlikely, it explicitly does not guard against people _attempting_ to cause a collision, and does not require GUIDs to be unguessable. This makes a GUID an extremely dangerous choice of token value.

Instead, the token value should be generated by either a true random number generator or a cryptographically strong pseudo-random number generator. A 128-bit value is _probably_ large enough, but I'd be inclined to play on the safe side and use a 256-bit value, which is still only going to be 40ish characters when base64 encoded.

The main advantages of an opaque token are its small size and the simplicity of implementation. However, the significant drawback is that every time it is used the service that needs to know about the user must retrieve the claims from the auth server, which adds latency to requests and means that if the auth server is down or otherwise inaccessible the operation will fail.

To mitigate the constant need to requery the auth server, it's fairly typical for clients to maintain a local session cache of the auth server information. This means that the advantages of opaque tokens aren't so clear cut, because token consumers may require more complex infrastructure to use them efficiently, and if they don't use them efficiently then the auth server could be subject to a lot more load than it was expecting.



## Self-Contained Tokens

I'm not really sure what the proper name for tokens that _aren't_ opaque is, because when people write about them they just tend to miss out the word 'opaque' and the lack of opacity is implied. 'Transparent' or 'clear' are the lexical opposites, but because the tokens are typically encrypted those words don't feel quite right. I'm choosing to call them self-contained tokens, because they contain all the information that's needed to make an authorisation decision.

Anyway, the key point is that you don't need to consult the auth server for additional information, and you don't need to look up the user details in any kind of session cache. You can just look at the token and decide whether the caller is allowed to perform the operation.






## Hybrid Patterns

- call back to verify on privileged operations


## Token Exchange Patterns

- RPs, STSs






